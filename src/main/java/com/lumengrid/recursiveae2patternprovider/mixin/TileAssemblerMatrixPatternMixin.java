package com.lumengrid.recursiveae2patternprovider.mixin;

import appeng.api.crafting.IPatternDetails;
import appeng.api.crafting.PatternDetailsHelper;
import appeng.api.networking.crafting.ICraftingProvider;
import appeng.api.stacks.AEItemKey;
import appeng.core.definitions.AEItems;
import appeng.crafting.pattern.AECraftingPattern;
import appeng.util.inv.AppEngInternalInventory;
import com.glodblock.github.extendedae.common.tileentities.matrix.TileAssemblerMatrixPattern;
import com.lumengrid.recursiveae2patternprovider.Config;
import com.lumengrid.recursiveae2patternprovider.RecursiveAE2PatternProvider;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.item.crafting.*;
import net.minecraft.world.level.Level;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Shadow;
import org.spongepowered.asm.mixin.Unique;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

import java.util.*;

@Mixin(TileAssemblerMatrixPattern.class)
public class TileAssemblerMatrixPatternMixin {
    @Unique
    private final List<IPatternDetails> recursivePatterns$autoGeneratedPatterns = new ArrayList<>();

    @Unique
    private final Set<String> recursivePatterns$processedRecipes = new HashSet<>();

    @Unique
    private final Set<String> recursivePatterns$processedItems = new HashSet<>();

    @Shadow
    private List<IPatternDetails> patterns;

    /**
     * Inject dependency pattern generation after the original updatePattern() completes
     */
    @Inject(method = "updatePatterns", at = @At("RETURN"), remap = false)
    private void injectDependencyPatterns(CallbackInfo ci) {
        try {
            if (!Config.ENABLE.get()) {
                return;
            }
            
            // Check if recursion is disabled
            int maxDepth = Config.RECURSION_DEPTH.get();
            if (maxDepth == 0) {
                return;
            }
            
            // Clear tracking sets
            recursivePatterns$processedRecipes.clear();
            recursivePatterns$processedItems.clear();

            TileAssemblerMatrixPattern self = (TileAssemblerMatrixPattern) (Object) this;
            
            // Get the level
            Level level = self.getLevel();
            if (level == null) {
                return;
            }

            // Collect manual patterns for dependency analysis (only recursive ones)
            List<IPatternDetails> recursivePatterns = new ArrayList<>();
            AppEngInternalInventory patternInventory = self.getPatternInventory();

            for (var stack : patternInventory) {
                var details = PatternDetailsHelper.decodePattern(stack, level);
                if (details != null && com.lumengrid.recursiveae2patternprovider.PatternUtil.isRecursive(stack)) {
                    recursivePatterns.add(details);
                    RecursiveAE2PatternProvider.LOGGER.debug("Found recursive pattern in Assembler Matrix ({}): {}", 
                        stack.getItem().builtInRegistryHolder().key().location(),
                        stack.getDisplayName().getString());
                }
            }

            recursivePatterns$autoGeneratedPatterns.clear();

            // Process only patterns marked as recursive
            for (IPatternDetails recursivePattern : recursivePatterns) {
                recursivePatterns$generateDependencyPatterns(recursivePattern, level, 0, maxDepth);
            }

            // Add auto-generated patterns to the main list
            this.patterns.addAll(recursivePatterns$autoGeneratedPatterns);

            if (!recursivePatterns$autoGeneratedPatterns.isEmpty()) {
                RecursiveAE2PatternProvider.LOGGER.info("Generated {} dependency patterns for Assembler Matrix Pattern",
                                 recursivePatterns$autoGeneratedPatterns.size());
                ICraftingProvider.requestUpdate(self.getMainNode());
            }
            
        } catch (Exception e) {
            RecursiveAE2PatternProvider.LOGGER.error("Failed to inject dependency patterns for Assembler Matrix: {}", e.getMessage(), e);
        }
    }

    /**
     * Recursively generate patterns for all dependencies of a given pattern
     */
    @Unique
    private void recursivePatterns$generateDependencyPatterns(IPatternDetails pattern, Level level, int currentDepth, int maxDepth) {
        if (level == null) return;
        
        // Check depth limit (-1 means no limit)
        if (maxDepth >= 0 && currentDepth >= maxDepth) {
            return;
        }
        
        RecipeManager recipeManager = level.getRecipeManager();
        var allRecipes = recipeManager.getAllRecipesFor(RecipeType.CRAFTING);
        
        for (var patternInput : pattern.getInputs()) {
            for (var inputCandidate : patternInput.getPossibleInputs()) {
                try {
                    var key = inputCandidate.what();
                    if (!(key instanceof AEItemKey itemKey)) {
                        continue;
                    }
                    
                    ItemStack inputStack = itemKey.toStack();
                    String itemId = inputStack.getItem().toString();
                    
                    if (recursivePatterns$processedItems.contains(itemId)) {
                        continue;
                    }
                    recursivePatterns$processedItems.add(itemId);
                    
                    recursivePatterns$findAndCreatePatternsForItem(inputStack, allRecipes, level, pattern, currentDepth, maxDepth);
                    
                } catch (Exception e) {
                    RecursiveAE2PatternProvider.LOGGER.debug("Error processing input candidate: {}", e.getMessage());
                }
            }
        }
    }
    
    /**
     * Find and create patterns for a specific item
     */
    @Unique
    private void recursivePatterns$findAndCreatePatternsForItem(ItemStack targetItem, 
                                                               Collection<RecipeHolder<CraftingRecipe>> allRecipes, 
                                                               Level level, IPatternDetails parentPattern,
                                                               int currentDepth, int maxDepth) {
        for (var recipe : allRecipes) {
            String recipeId = recipe.id().toString();

            if (recursivePatterns$processedRecipes.contains(recipeId)) {
                continue;
            }
            
            try {
                ItemStack recipeOutput = recipe.value().getResultItem(level.registryAccess());
                if (recipeOutput.isEmpty() || !recipeOutput.is(targetItem.getItem())) {
                    continue;
                }
                
                if (ItemStack.isSameItemSameComponents(targetItem, recipeOutput)) {
                    recursivePatterns$processedRecipes.add(recipeId);
                    
                    ItemStack[] inputs = recursivePatterns$getRecipeInputsAs3x3Grid(recipe.value());
                    ItemStack patternStack = AEItems.CRAFTING_PATTERN.stack();
                    
                    // Extract substitute settings from parent pattern
                    boolean allowSubstitutes = Config.DEFAULT_ALLOW_SUBSTITUTES.get();
                    boolean allowFluidSubstitutes = Config.DEFAULT_ALLOW_FLUID_SUBSTITUTES.get();
                    
                    // If parent pattern is an AECraftingPattern, inherit its substitute settings
                    if (parentPattern instanceof AECraftingPattern parentCraftingPattern) {
                        allowSubstitutes = parentCraftingPattern.canSubstitute();
                        allowFluidSubstitutes = parentCraftingPattern.canSubstituteFluids();
                    }
                    
                    AECraftingPattern.encode(patternStack, recipe, inputs, recipeOutput, allowSubstitutes, allowFluidSubstitutes);
                    AECraftingPattern aePattern = new AECraftingPattern(
                        Objects.requireNonNull(AEItemKey.of(patternStack)), level);
                    
                    if (aePattern.getOutputs() != null && !aePattern.getOutputs().isEmpty()) {
                        recursivePatterns$autoGeneratedPatterns.add(aePattern);
                        // Continue recursion with incremented depth
                        recursivePatterns$generateDependencyPatterns(aePattern, level, currentDepth + 1, maxDepth);
                    }
                }
                
            } catch (Exception e) {
                RecursiveAE2PatternProvider.LOGGER.debug("Failed to create dependency pattern for recipe: {} - {}",
                                   recipe.id(), e.getMessage());
            }
        }
    }

    /**
     * Convert recipe ingredients to a 3x3 grid format
     */
    @Unique
    private ItemStack[] recursivePatterns$getRecipeInputsAs3x3Grid(CraftingRecipe recipe) {
        ItemStack[] inputs = new ItemStack[9];
        Arrays.fill(inputs, ItemStack.EMPTY);
        
        var ingredients = recipe.getIngredients();
        
        if (recipe instanceof ShapedRecipe shapedRecipe) {
            int width = shapedRecipe.getWidth();
            int height = shapedRecipe.getHeight();
            
            for (int y = 0; y < height; y++) {
                for (int x = 0; x < width; x++) {
                    int ingredientIndex = y * width + x;
                    int gridIndex = y * 3 + x;
                    
                    if (ingredientIndex < ingredients.size()) {
                        var ingredient = ingredients.get(ingredientIndex);
                        if (!ingredient.isEmpty() && ingredient.getItems().length > 0) {
                            inputs[gridIndex] = ingredient.getItems()[0].copy();
                        }
                    }
                }
            }
        } else {
            int index = 0;
            for (var ingredient : ingredients) {
                if (!ingredient.isEmpty() && ingredient.getItems().length > 0 && index < 9) {
                    inputs[index] = ingredient.getItems()[0].copy();
                    index++;
                }
            }
        }
        
        return inputs;
    }
}

